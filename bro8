
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Players = game:GetService("Players")
local VirtualInputManager = game:GetService("VirtualInputManager")
local http = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer

-- Get current place ID to determine which features to show
local CurrentPlaceId = game.PlaceId
print("Current Place ID: " .. CurrentPlaceId)
local isInMainMenu = (CurrentPlaceId == 13379208636)


local Window = Fluent:CreateWindow({
    Title = "Attack On Titan Revolution " .. Fluent.Version,
    SubTitle = "by Ahjin",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})

-- Create all tabs regardless of game state
local Tabs = {
    Features = Window:AddTab({ Title = "Features", Icon = "rocket" }),
	Teleport = Window:AddTab({ Title = "Teleport", Icon = "map-pin" }),
    Tracker = Window:AddTab({ Title = "Rewards Tracker", Icon = "eye" }),
    Visual = Window:AddTab({ Title = "Visual", Icon = "palette" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options

-- Welcome notification
Fluent:Notify({
    Title = "AOT:R Autofarm",
    Content = "Script has been loaded successfully. Current Place ID: " .. CurrentPlaceId,
    Duration = 5
})

-- Function for the Nape Extender feature
local function extendNape()
    while Options.NapeExtender.Value do
        if not Options.NapeExtender.Value then return end
        
        -- Check if Titans folder exists
        local titansFolder = game:GetService("Workspace"):FindFirstChild("Titans")
        if not titansFolder then
            print("Titans folder not found. Wait and retry...")
            wait(1)
            continue
        end
        
        for i, titans in pairs(titansFolder:GetChildren()) do
            local stepone = titans:FindFirstChild("Hitboxes")
            if stepone then
                local steptwo = stepone:FindFirstChild("Hit")
                if steptwo then
                    local final = steptwo:FindFirstChild("Nape")
                    if final then
                        final.Size = Vector3.new(Options.HitboxSize.Value, Options.HitboxSize.Value, Options.HitboxSize.Value)
                        final.Transparency = 0.85
                        final.CanCollide = false
                        print("Extended Nape For:", titans.Name)
                    end
                end
            end
        end
        wait(0.05)
    end
end

-- Add features to the Features tab based on game state
if not isInMainMenu then
    -- Add Nape Extender toggle
    local NapeToggle = Tabs.Features:AddToggle("NapeExtender", {
        Title = "Nape Extender",
        Default = false,
        Description = "Enlarges titan nape hitboxes for easier hits",
        Callback = function(Value)
            if Value then
                task.spawn(extendNape)
            end
        end
    })

    -- Add the autofarm toggle
    local AutofarmToggle = Tabs.Features:AddToggle("Autofarm", {
        Title = "OP Autofarm",
        Default = false,
        Description = "Required Steel, Trust skills",
        Callback = function(Value)
            if Value then
                local Players = game:GetService("Players")
                local workspace = game:GetService("Workspace")
                local VIP = game:GetService("VirtualInputManager")
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local RunService = game:GetService("RunService")

                local player = Players.LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                local rootPart = character:WaitForChild("HumanoidRootPart")

                -- Enlarge titan hitboxes
                local titans = workspace.Titans:GetChildren()
                for _, titan in ipairs(titans) do
                    local Hitboxes = titan:FindFirstChild("Hitboxes")
                    if Hitboxes then
                        local Hit = Hitboxes:FindFirstChild("Hit")
                        if Hit then
                            local Nape = Hit:FindFirstChild("Nape")
                            if Nape then
                                print("Found Nape")
                                
                                -- Resize the Nape hitbox
                                Nape.Size = Vector3.new(Options.HitboxSize.Value, Options.HitboxSize.Value, Options.HitboxSize.Value)
                                
                                -- Teleport Nape to 5 studs in front of the player's character
                                local frontOffset = rootPart.CFrame.LookVector * 5
                                Nape.Position = rootPart.Position + frontOffset
                                
                                -- Ensure Nape is anchored
                                Nape.Anchored = true
                            end
                        end
                    end
                end

                -- The fixed position you want to lock the player to
                local fixedPosition = Vector3.new(rootPart.Position.X, rootPart.Position.Y, rootPart.Position.Z)
                
                -- Allowable vertical movement range
                local verticalRange = 5
                
                -- Function to keep the player in place
                local function keepPlayerInPlace()
                    local yPos = math.clamp(rootPart.Position.Y, fixedPosition.Y - verticalRange, fixedPosition.Y + verticalRange)
                    rootPart.CFrame = CFrame.new(fixedPosition.X, yPos, fixedPosition.Z)
                end
                
                -- Run the function on every frame
                local connectionRef = RunService.RenderStepped:Connect(keepPlayerInPlace)
                
                -- Simulate key event for the first skill
                VIP:SendKeyEvent(true, Enum.KeyCode.One, false, game)
                task.wait(0.1)
                
                -- Find Thrust and Steel parts and modify them
                local Thrust = workspace:FindFirstChild("HakerOreoScary_Thrust")
                local Steel = workspace:FindFirstChild("HakerOreoScary_Steel")
                
                if Thrust then
                    Thrust.Size = Vector3.new(1999, 1999, 1999)
                    Thrust.CanCollide = false
                end
                
                task.wait(2)
                
                -- Simulate key event for the second skill
                VIP:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
                task.wait(0.1)
                
                if Steel then
                    Steel.Size = Vector3.new(1999, 1999, 1999)
                    Steel.CanCollide = false
                end
                
                -- Path to the Slay object
                local Slay = ReplicatedStorage.Objectives:WaitForChild("Slay")
                
                -- Requirement attribute
                local requirement = Slay:GetAttribute("Requirement")
                
                -- Wait for Slay.Value to meet the requirement before proceeding with key events
                while Slay.Value ~= requirement do
                    task.wait(0.1)
                    -- Check if toggle was turned off
                    if not Options.Autofarm.Value then
                        if connectionRef then
                            connectionRef:Disconnect()
                        end
                        return
                    end
                end
                
                task.wait(1)
                
                VIP:SendKeyEvent(true, Enum.KeyCode.BackSlash, false, game)
                task.wait(0.1)
                VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
                task.wait(0.1)
                VIP:SendKeyEvent(true, Enum.KeyCode.Right, false, game)
                task.wait(0.1)
                VIP:SendKeyEvent(true, Enum.KeyCode.Return, false, game) -- Key down
                VIP:SendKeyEvent(false, Enum.KeyCode.Return, false, game) -- Key up
            end
        end
    })

    -- Add a hitbox size slider to Features tab
    local HitboxSlider = Tabs.Features:AddSlider("HitboxSize", {
        Title = "Hitbox Size",
        Description = "Adjust the size of titan hitboxes",
        Default = 250,
        Min = 10,
        Max = 500,
        Rounding = 0,
        Callback = function(Value)
            -- This value will be used in the Nape Extender function
            print("Hitbox size set to:", Value)
        end
    })

	local AutoEscapeToggle = Tabs.Features:AddToggle("AutoEscapeEnabled", {
    Title = "Auto Escape",
    Default = false,
    Description = "",
    Callback = function(Value)
        -- Auto Escape Script
        local VIM = game:GetService("VirtualInputManager")
        getgenv().autoescape = Value
        
        if Value then
            -- Create a new connection when enabled
            _G.AutoEscapeConnection = task.spawn(function()
                while task.wait(0.3) do 
                    if not getgenv().autoescape then break end 
                    for i,v in pairs(game:GetService("Players").LocalPlayer.PlayerGui.Interface.Buttons:GetChildren()) do 
                        if v ~= nil then 
                            VIM:SendKeyEvent(true, string.sub(tostring(v), 1, 1), false, game) 
                        end 
                    end
                end
            end)
        else
            -- Stop the loop when disabled
            getgenv().autoescape = false
            if _G.AutoEscapeConnection then
                task.cancel(_G.AutoEscapeConnection)
                _G.AutoEscapeConnection = nil
            end
        end
    end
})

-- Add Anti-Injury feature
local AntiInjuryToggle = Tabs.Features:AddToggle("AntiInjury", {
    Title = "Anti Injury",
    Default = false,
    Callback = function(Value)
        if Value then
            -- Enable Anti-Injury
            local Players = game:GetService("Players")
            local lp = Players.LocalPlayer
            local char = lp.Character or lp.CharacterAdded:Wait()
            
            -- Create a function to handle all Anti-Injury logic
            local function setupAntiInjury(character)
                local humanoid = character:WaitForChild("Humanoid")
                
                -- Prevent ragdoll and hurt animations
                for _, v in ipairs(character:GetDescendants()) do
                    if v:IsA("RemoteEvent") and (v.Name:lower():find("hurt") or v.Name:lower():find("ragdoll")) then
                        v:Destroy()
                    end
                end
                
                -- Constantly block new ragdoll/hurt events
                local descendantConn = character.DescendantAdded:Connect(function(obj)
                    if obj:IsA("RemoteEvent") and (obj.Name:lower():find("hurt") or obj.Name:lower():find("ragdoll")) then
                        obj:Destroy()
                    end
                end)
                
                -- Restore health if reduced (basic protection)
                local lastHealth = humanoid.Health
                local healthConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
                    if humanoid.Health < lastHealth then
                        humanoid.Health = lastHealth
                    else
                        lastHealth = humanoid.Health
                    end
                end)
                
                -- Auto-fix if Humanoid gets forced into ragdoll states
                local stateConn = humanoid.StateChanged:Connect(function(old, new)
                    if new == Enum.HumanoidStateType.Ragdoll or 
                       new == Enum.HumanoidStateType.Physics or 
                       new == Enum.HumanoidStateType.FallingDown then
                        humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
                    end
                end)
                
                -- Store connections for cleanup
                character:SetAttribute("AntiInjuryEnabled", true)
                character:SetAttribute("AntiInjuryDescConn", tostring(descendantConn))
                character:SetAttribute("AntiInjuryHealthConn", tostring(healthConn))
                character:SetAttribute("AntiInjuryStateConn", tostring(stateConn))
            end
            
            -- Set up anti-injury for current character
            if char then
                setupAntiInjury(char)
            end
            
            -- Handle character respawn
            lp.CharacterAdded:Connect(function(newChar)
                if AntiInjuryToggle:GetState() then
                    setupAntiInjury(newChar)
                end
            end)
        else
            -- Disable Anti-Injury
            local lp = Players.LocalPlayer
            local char = lp.Character
            
            if char and char:GetAttribute("AntiInjuryEnabled") then
                char:SetAttribute("AntiInjuryEnabled", false)
                -- Clean up connections would go here if we had a way to store them
                -- For now we'll just flag it as disabled
            end
        end
    end
})

-- Information paragraph for Features tab
    Tabs.Features:AddParagraph({
        Title = "Information",
        Content = "auto-kills titans by making their weak spots bigger and attacking for you."
    })
else

    -- Add a message for Features tab when in main menu
    Tabs.Features:AddParagraph({
        Title = "Combat Features Unavailable",
        Content = "Combat features are only available during missions. Please join a mission to access Nape Extender, Autofarm, and other combat features."
    })
end

-- First create a dropdown for the slashing mode
local SlashModeDropdown = Tabs.Features:AddDropdown("SlashMode", {
    Title = "Farm Mode",
    Values = {"Risky", "Safe", "Normal"},
    Default = "Normal",
    Multi = false,
    Description = "Your Choice"
})

-- Then create the toggle with the dropdown reference
local SlashThroughHitboxToggle = Tabs.Features:AddToggle("SlashThroughHitbox", {
    Title = "Auto Farm",
    Default = false,
    Description = "",
    Callback = function(Value)
        _G.SlashThroughHitboxEnabled = Value -- Global variable to track state
        
        if Value then
            -- Services
            local Players = game:GetService("Players")
            local Workspace = game:GetService("Workspace")
            local VIM = game:GetService("VirtualInputManager")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local RunService = game:GetService("RunService")
            local TweenService = game:GetService("TweenService")

            -- Get the current slash mode
            local currentSlashMode = SlashModeDropdown.Value

            -- Configuration
            local Options = {
                AutoFarm = { Value = true },
                NapeExtender = { Value = true },
                HitboxSize = { Value = 35 },
                MoveSpeed = 120,
                SlashSpeed = 130,
                SlashDistance = 15,
                AttackDuration = 4,
                WaitAfterCompletion = 2.5,
                ClickOffsetX = 50,
                ClickOffsetY = 60,
                AttackHeight = { Value = 300 } -- Fixed at 300 studs
            }

            -- Adjust settings based on selected mode
            if currentSlashMode == "Risky" then
                -- Risky mode: Faster movement, higher attack speed
                Options.MoveSpeed = 300
                Options.SlashSpeed = 150
            elseif currentSlashMode == "Safe" then
                -- Safe mode: Slower movement, more careful
                Options.MoveSpeed = 70    -- Slower movement
                Options.SlashSpeed = 90   -- Slower slashing
                Options.AttackDuration = 5 -- Longer attacks for more precision
            end

            -- References
            local player = Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:WaitForChild("HumanoidRootPart")
            
            -- Connections for cleanup
            local connections = {}
            local currentTween = nil
            local isSlashing = false
            local currentTargetTitan = nil  -- Track the current titan being targeted
            local lastGroundY = hrp.Position.Y -- Track last ground Y position

            -- Function to check if a titan is alive and valid
            local function isTitanValid(titan)
                return titan and 
                       titan:IsDescendantOf(Workspace) and 
                       titan:FindFirstChild("Humanoid") and 
                       titan.Humanoid.Health > 0
            end

            -- This function will continuously check if the current target titan is still valid
            local function setupTitanMonitor()
                local connection = RunService.Heartbeat:Connect(function()
                    if currentTargetTitan and not isTitanValid(currentTargetTitan) then
                        -- Titan died or became invalid, force stop slashing
                        isSlashing = false
                        currentTargetTitan = nil
                    end
                end)
                table.insert(connections, connection)
            end

            -- Movement function with fixed height implementation
            local function moveToPosition(targetPos, titan)
                if not isTitanValid(titan) then
                    return false
                end
                
                -- Always set the y-position to the fixed height of 300
                targetPos = Vector3.new(targetPos.X, Options.AttackHeight.Value, targetPos.Z)

                -- Normal movement for all modes
                local distance = (targetPos - hrp.Position).Magnitude
                local duration = distance / Options.MoveSpeed
                local startTime = tick()
                
                local startPos = hrp.Position
                
                while tick() - startTime < duration and _G.SlashThroughHitboxEnabled do
                    -- Check if titan is still valid during movement
                    if not isTitanValid(titan) then
                        return false
                    end
                    
                    local alpha = (tick() - startTime) / duration
                    alpha = math.min(alpha, 1)
                    
                    local newPos = startPos:Lerp(targetPos, alpha)
                    hrp.CFrame = CFrame.new(newPos)
                    
                    task.wait()
                end
                
                return _G.SlashThroughHitboxEnabled
            end
            
            -- Slash function with fixed height implementation
            local function moveSlash(startPos, endPos, titan)
                if not isTitanValid(titan) then
                    return false
                end
                
                -- Ensure both start and end positions are at fixed height of 300
                startPos = Vector3.new(startPos.X, Options.AttackHeight.Value, startPos.Z)
                endPos = Vector3.new(endPos.X, Options.AttackHeight.Value, endPos.Z)
                
                -- Normal movement for all modes
                local distance = (endPos - startPos).Magnitude
                local duration = distance / Options.SlashSpeed
                local startTime = tick()
                
                while tick() - startTime < duration and _G.SlashThroughHitboxEnabled do
                    -- Check if titan is still valid during slash
                    if not isTitanValid(titan) then
                        return false
                    end
                    
                    local alpha = (tick() - startTime) / duration
                    alpha = math.min(alpha, 1)
                    
                    local newPos = startPos:Lerp(endPos, alpha)
                    hrp.CFrame = CFrame.new(newPos)
                    
                    task.wait()
                end
                
                return _G.SlashThroughHitboxEnabled
            end
            
            -- Slash through nape function with improved titan validity checks
            -- and fixed height implementation
            local function slashThroughNape(napePart, titan)
                if isSlashing then return true end
                
                -- Don't start slashing if titan is already dead
                if not isTitanValid(titan) then
                    return false
                end
                
                isSlashing = true
                currentTargetTitan = titan  -- Set the current target titan
                
                local startTime = tick()
                local slashCount = 0
                local slashDirections = {
                    {Vector3.new(-Options.SlashDistance, 0, 0), Vector3.new(Options.SlashDistance, 0, 0)},
                    {Vector3.new(0, -Options.SlashDistance, 0), Vector3.new(0, Options.SlashDistance, 0)},
                    {Vector3.new(0, 0, -Options.SlashDistance), Vector3.new(0, 0, Options.SlashDistance)},
                    {Vector3.new(-Options.SlashDistance, -Options.SlashDistance, 0), Vector3.new(Options.SlashDistance, Options.SlashDistance, 0)},
                    {Vector3.new(-Options.SlashDistance, 0, -Options.SlashDistance), Vector3.new(Options.SlashDistance, 0, Options.SlashDistance)}
                }
                
                -- For Safe mode, use fewer slice directions to be more methodical
                if currentSlashMode == "Safe" then
                    -- Use only the most reliable slash directions
                    slashDirections = {
                        {Vector3.new(-Options.SlashDistance, 0, 0), Vector3.new(Options.SlashDistance, 0, 0)},
                        {Vector3.new(0, -Options.SlashDistance, 0), Vector3.new(0, Options.SlashDistance, 0)}
                    }
                end
                
                -- This coroutine handles the slashing
                local slashCoroutine = task.spawn(function()
                    while (tick() - startTime) < Options.AttackDuration and _G.SlashThroughHitboxEnabled and isSlashing do
                        -- Immediately exit if titan is no longer valid
                        if not isTitanValid(titan) then
                            isSlashing = false
                            currentTargetTitan = nil
                            break
                        end
                        
                        local currentDirection = (slashCount % #slashDirections) + 1
                        local dir = slashDirections[currentDirection]
                        
                        local napePos = napePart.Position
                        -- Always adjust for fixed height of 300
                        napePos = Vector3.new(napePos.X, Options.AttackHeight.Value, napePos.Z)
                        
                        local startPos = napePos + dir[1]
                        local endPos = napePos + dir[2]
                        
                        local slashSuccess = moveSlash(startPos, endPos, titan)
                        if not slashSuccess then
                            isSlashing = false
                            currentTargetTitan = nil
                            break
                        end
                        
                        slashSuccess = moveSlash(endPos, startPos, titan)
                        if not slashSuccess then
                            isSlashing = false
                            currentTargetTitan = nil
                            break
                        end
                        
                        slashCount = slashCount + 1
                    end
                    
                    isSlashing = false
                    currentTargetTitan = nil
                end)
                
                -- Wait for slashing to complete or for titan to become invalid
                local waitEndTime = tick() + Options.AttackDuration
                while tick() < waitEndTime and _G.SlashThroughHitboxEnabled and isSlashing do
                    -- Exit early if titan becomes invalid
                    if not isTitanValid(titan) then
                        isSlashing = false
                        currentTargetTitan = nil
                        break
                    end
                    
                    task.wait(0.1)
                    if not _G.SlashThroughHitboxEnabled or not isSlashing then
                        break
                    end
                end
                
                task.wait(0.2)
                isSlashing = false
                currentTargetTitan = nil
                
                return _G.SlashThroughHitboxEnabled
            end

            -- Modified NoClip function that still prevents falling
            local function enableNoClip()
                -- For fixed height, update lastGroundY to match our desired height
                lastGroundY = Options.AttackHeight.Value - 3 -- Set a reference point below our fixed height
                
                -- Disable collision for parts
                local connection = RunService.Stepped:Connect(function()
                    if character and character:FindFirstChild("Humanoid") then
                        for _, part in pairs(character:GetDescendants()) do
                            if part:IsA("BasePart") then
                                part.CanCollide = false
                            end
                        end
                    end
                end)
                table.insert(connections, connection)
                
                -- Height correction for fixed height
                local heightCorrectionConnection = RunService.Heartbeat:Connect(function()
                    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
                    
                    -- If we're not at the right height, correct it
                    if math.abs(hrp.Position.Y - Options.AttackHeight.Value) > 5 then
                        hrp.CFrame = CFrame.new(
                            hrp.Position.X, 
                            Options.AttackHeight.Value, 
                            hrp.Position.Z
                        ) * CFrame.Angles(hrp.CFrame:ToEulerAnglesXYZ())
                    end
                end)
                table.insert(connections, heightCorrectionConnection)
            end
            
            -- Setup M1 auto-clicker with 1 click per second
            _G.M1SlashFarm = true
            task.spawn(function()
                while _G.M1SlashFarm and _G.SlashThroughHitboxEnabled do
                    VIM:SendMouseButtonEvent(0, 0, 0, true, game, 0)
                    task.wait(0.1)  -- Short press
                    VIM:SendMouseButtonEvent(0, 0, 0, false, game, 0)
                    task.wait(0.9)  -- Wait for remainder of second
                end
            end)
            
            -- Check mission completion and auto-retry with rate limiting
            local function checkMissionCompletion()
                local lastRetryTime = 0
                local retryAttempted = false
                local retryDelay = 10 -- Minimum seconds between retry attempts
                
                local connection = RunService.Heartbeat:Connect(function()
                    if not _G.SlashThroughHitboxEnabled then return end
                    
                    -- Only check every 3 seconds to reduce frequency
                    if tick() % 3 > 0.1 then return end
                    
                    local Slay = ReplicatedStorage.Objectives:FindFirstChild("Slay")
                    
                    if Slay then
                        local value = Slay.Value
                        local requirement = Slay:GetAttribute("Requirement")
                        
                        if value and requirement and value >= requirement then
                            -- Prevent spamming retry
                            if retryAttempted then return end
                            
                            -- Rate limit retry attempts
                            if tick() - lastRetryTime < retryDelay then return end
                            
                            retryAttempted = true
                            lastRetryTime = tick()
                            
                            task.wait(Options.WaitAfterCompletion)
                            
                            local playerGui = game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui")
                            if not playerGui then 
                                retryAttempted = false
                                return 
                            end
                            
                            local interface = playerGui:FindFirstChild("Interface")
                            if not interface then 
                                retryAttempted = false
                                return 
                            end
                            
                            local rewards = interface:FindFirstChild("Rewards")
                            if not rewards then 
                                retryAttempted = false
                                return 
                            end
                            
                            local main = rewards:FindFirstChild("Main")
                            if not main then 
                                retryAttempted = false
                                return 
                            end
                            
                            local info = main:FindFirstChild("Info")
                            if not info then 
                                retryAttempted = false
                                return 
                            end
                            
                            local mainInfo = info:FindFirstChild("Main")
                            if not mainInfo then 
                                retryAttempted = false
                                return 
                            end
                            
                            local buttons = mainInfo:FindFirstChild("Buttons")
                            if not buttons then 
                                retryAttempted = false
                                return 
                            end
                            
                            local retryButton = buttons:FindFirstChild("Retry")
                            
                            if retryButton then
                                local buttonPos = retryButton.AbsolutePosition
                                local buttonSize = retryButton.AbsoluteSize
                                
                                local clickX = buttonPos.X + (buttonSize.X / 2) + Options.ClickOffsetX
                                local clickY = buttonPos.Y + (buttonSize.Y / 2) + Options.ClickOffsetY
                                
                                VIM:SendMouseButtonEvent(clickX, clickY, 0, true, game, 0)
                                task.wait(0.1)
                                VIM:SendMouseButtonEvent(clickX, clickY, 0, false, game, 0)
                            end
                            
                            -- Reset retry flag after 5 seconds
                            task.delay(5, function()
                                retryAttempted = false
                            end)
                        end
                    end
                end)
                
                table.insert(connections, connection)
            end

            -- Main auto-farm loop with improved titan targeting and fixed height support
            local function autoFarm()
                while not Workspace:FindFirstChild("Titans") do
                    task.wait(1)
                    if not _G.SlashThroughHitboxEnabled then return end
                end

                while _G.SlashThroughHitboxEnabled and Options.AutoFarm.Value do
                    local titansFolder = Workspace:FindFirstChild("Titans")
                    if not titansFolder then
                        task.wait(1)
                        continue
                    end
                    
                    -- Make sure we're not already slashing
                    if isSlashing then
                        task.wait(0.5)
                        continue
                    end
                    
                    local titanList = {}
                    for _, titan in ipairs(titansFolder:GetChildren()) do
                        if not titan:IsA("Model") then continue end
                        
                        -- Important fix: Check titan is alive
                        if not isTitanValid(titan) then continue end
                        
                        local hitboxes = titan:FindFirstChild("Hitboxes")
                        local hit = hitboxes and hitboxes:FindFirstChild("Hit")
                        local nape = hit and hit:FindFirstChild("Nape")
                        
                        if nape then
                            table.insert(titanList, { titan = titan, nape = nape })
                        end
                    end
                    
                    -- Sort titans by distance (only X and Z, not Y since we're at fixed height)
                    table.sort(titanList, function(a, b)
                        local aPos = Vector3.new(a.nape.Position.X, 0, a.nape.Position.Z)
                        local bPos = Vector3.new(b.nape.Position.X, 0, b.nape.Position.Z)
                        local playerPos = Vector3.new(hrp.Position.X, 0, hrp.Position.Z)
                        return (aPos - playerPos).Magnitude < (bPos - playerPos).Magnitude
                    end)

                    local targetedTitan = false
                    for _, entry in ipairs(titanList) do
                        if not _G.SlashThroughHitboxEnabled then break end
                        
                        local titan = entry.titan
                        local nape = entry.nape

                        -- Check again that titan is still valid before targeting
                        if not isTitanValid(titan) then continue end
                        
                        targetedTitan = true
                        currentTargetTitan = titan  -- Set current target titan

-- Find the NapeExtender code in the autoFarm function and replace it with this:

if Options.NapeExtender.Value then
    -- Check if this is a crawler titan by looking at its attributes
    local isCrawler = titan:GetAttribute("Type") == "Crawler"
    
    local titanBase = nape.Position
    local heightDifference = math.abs(Options.AttackHeight.Value - titanBase.Y)
    
    if isCrawler then
        -- For crawlers: make a large vertical column that's guaranteed to hit
        nape.Size = Vector3.new(
            Options.HitboxSize.Value * 1.5,    -- Much wider X
            heightDifference * 1,            -- Very tall to guarantee hit
            Options.HitboxSize.Value * 11     -- Much deeper Z
        )
        
        -- Position directly above the crawler
        nape.Position = Vector3.new(
            titanBase.X,
            (titanBase.Y + Options.AttackHeight.Value) / 2, -- Centered between crawler and player
            titanBase.Z
        )
    else
        -- Normal titan (unchanged)
        nape.Size = Vector3.new(
            Options.HitboxSize.Value,  -- Width X
            heightDifference + 60,     -- Height Y
            Options.HitboxSize.Value   -- Width Z
        )
        
        -- Position the nape so it extends from titan up to our height
        local midPoint = (titanBase.Y + Options.AttackHeight.Value) / 2
        nape.Position = Vector3.new(
            titanBase.X,
            midPoint,
            titanBase.Z
        )
    end
    
    nape.Transparency = 0.45
    nape.CanCollide = false
end
                        local targetPos = Vector3.new(nape.Position.X, Options.AttackHeight.Value, nape.Position.Z)
                        
                        local success = moveToPosition(targetPos, titan)
                        if not success then
                            currentTargetTitan = nil
                            break
                        end
                        
                        -- Pass titan instance to slashThroughNape
                        local slashSuccess = slashThroughNape(nape, titan)
                        if not slashSuccess then
                            currentTargetTitan = nil
                            break
                        end
                    end
                    
                    currentTargetTitan = nil
                    
                    if not targetedTitan then
                        task.wait(1)
                    else
                        task.wait(0.05)
                    end
                end
            end

            -- Cleanup function
            local function cleanup()
                isSlashing = false
                currentTargetTitan = nil
                
                for _, connection in pairs(connections) do
                    if connection and connection.Connected then
                        connection:Disconnect()
                    end
                end
                
                if currentTween then
                    currentTween:Cancel()
                    currentTween = nil
                end
                
                _G.M1SlashFarm = false
            end

            -- Setup cleanup on toggle off
            local toggleOffConnection = RunService.Heartbeat:Connect(function()
                if not _G.SlashThroughHitboxEnabled then
                    cleanup()
                    toggleOffConnection:Disconnect()
                end
            end)
            table.insert(connections, toggleOffConnection)

            -- Run farm
            enableNoClip()
            checkMissionCompletion()
            setupTitanMonitor()  -- Add titan monitor
            
            -- Setup cleanup on character respawn
            local characterConnection = player.CharacterAdded:Connect(function(newCharacter)
                character = newCharacter
                hrp = character:WaitForChild("HumanoidRootPart")
                task.wait(1)
                enableNoClip()
            end)
            table.insert(connections, characterConnection)
            
            -- Start farming
            task.spawn(autoFarm)
            
        else
            -- Disable farm when toggle is turned off
            _G.SlashThroughHitboxEnabled = false
            _G.M1SlashFarm = false
        end
    end
})

-- Add event listener to update when dropdown changes while toggle is active
SlashModeDropdown:OnChanged(function()
    if _G.SlashThroughHitboxEnabled then
        -- Turn off and back on to apply new settings
        SlashThroughHitboxToggle:Set(false)
        task.wait(0.5)
        SlashThroughHitboxToggle:Set(true)
    end
end)

-- Add Auto Blade Reload Toggle to Features Tab (IMPROVED VERSION USING DIRECT REMOTES)
local BladeReloadToggle = Tabs.Features:AddToggle("BladeReload", {
    Title = "Auto Blade Reload",
    Default = false,
    Description = "",
    Callback = function(Value)
        if Value then
            -- Variables for blade reload
            local Players = game:GetService("Players")
            local player = Players.LocalPlayer
            local RunService = game:GetService("RunService")
            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            
            -- Setup remote function
            local remote = ReplicatedStorage:WaitForChild("Assets"):WaitForChild("Remotes"):WaitForChild("GET")
            
            -- Variables for timing and state
            local lastReloadTime = 0
            local RELOAD_COOLDOWN = 10 -- Seconds to wait between reload attempts
            local isReloading = false
            
            -- Direct server reload function (more reliable than key simulation)
            local function reloadBladesViaRemote()
                local currentTime = tick()
                
                -- Check cooldown and prevent spam
                if currentTime - lastReloadTime < RELOAD_COOLDOWN then
                    return
                end
                
                -- Set reloading state to prevent multiple simultaneous calls
                if isReloading then return end
                isReloading = true
                
                -- Call server remote directly
                print("Reloading blades via remote...")
                pcall(function()
                    remote:InvokeServer("Blades", "Reload")
                end)
                
                -- Update last reload time
                lastReloadTime = currentTime
                isReloading = false
            end
            
            -- Fallback function using key simulation (in case remote fails)
            local function fallbackKeyReload()
                local currentTime = tick()
                
                -- Check cooldown
                if currentTime - lastReloadTime < RELOAD_COOLDOWN then
                    return
                end
                
                -- Use VirtualInputManager as fallback
                local VirtualInputManager = game:GetService("VirtualInputManager")
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, game)
                task.wait(0.05)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, game)
                
                -- Update last reload time
                lastReloadTime = currentTime
            end
            
            -- Main monitoring loop for blade transparency
            local reloadConnection = RunService.Heartbeat:Connect(function()
                if not Options.BladeReload.Value then return end
                
                -- Check if character exists
                local character = workspace.Characters:FindFirstChild(player.Name)
                if not character then return end
                
                local rig = character:FindFirstChild("Rig_"..player.Name)
                if not rig then return end
                
                local rightHand = rig:FindFirstChild("RightHand")
                local leftHand = rig:FindFirstChild("LeftHand")
                
                -- Check if both hands exist
                if not (rightHand and leftHand) then return end
                
                -- Look specifically for Blade_1 in each hand
                local rightBlade = rightHand:FindFirstChild("Blade_1")
                local leftBlade = leftHand:FindFirstChild("Blade_1")
                
                -- Check if either Blade_1 has exactly Transparency = 1
                if (rightBlade and rightBlade.Transparency == 1) or 
                   (leftBlade and leftBlade.Transparency == 1) then
                    -- Try remote first, with fallback to key press
                    local success = pcall(function()
                        reloadBladesViaRemote()
                    end)
                    
                    -- If remote call failed, use key press as fallback
                    if not success then
                        print("Remote reload failed, using fallback key press")
                        fallbackKeyReload()
                    end
                end
            end)
            
            -- Cleanup function
            task.spawn(function()
                while Options.BladeReload.Value do task.wait(0.1) end
                
                if reloadConnection then
                    reloadConnection:Disconnect()
                end
            end)
            
            Fluent:Notify({
                Title = "Auto Blade Reload Enabled",
                Content = "",
                Duration = 3
            })
        end
    end
})


-- Add features to the Visual tab - some are conditional
if not isInMainMenu then
    -- Add Titan ESP toggle to the Visual tab
    local ESPToggle = Tabs.Visual:AddToggle("TitanESP", {
        Title = "Titan ESP",
        Default = false,
        Description = "",
        Callback = function(Value)
            if Value then
                local titansFolder = game.Workspace:FindFirstChild("Titans")
                if not titansFolder then
                    Fluent:Notify({
                        Title = "Error",
                        Content = "Titans folder not found. Are you in a mission?",
                        Duration = 3
                    })
                    return
                end
                
                for _, titan in pairs(titansFolder:GetChildren()) do
                    -- Check if highlight already exists
                    if not titan:FindFirstChild("Highlight") then
                        local highlight = Instance.new("Highlight")
                        highlight.Parent = titan
                        highlight.Archivable = true
                        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                        highlight.Enabled = true
                        highlight.FillColor = Color3.fromRGB(255, 0, 4)
                        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                        highlight.FillTransparency = 0.5
                        highlight.OutlineTransparency = 0
                    end
                end
                
                -- Connect to ChildAdded to highlight new titans
                game.Workspace.Titans.ChildAdded:Connect(function(titan)
                    if Options.TitanESP.Value then
                        local highlight = Instance.new("Highlight")
                        highlight.Parent = titan
                        highlight.Archivable = true
                        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                        highlight.Enabled = true
                        highlight.FillColor = Color3.fromRGB(255, 0, 4)
                        highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                        highlight.FillTransparency = 0.5
                        highlight.OutlineTransparency = 0
                    end
                end)
            else
                -- Remove highlights when toggled off
                local titansFolder = game.Workspace:FindFirstChild("Titans")
                if titansFolder then
                    for _, titan in pairs(titansFolder:GetChildren()) do
                        local highlight = titan:FindFirstChild("Highlight")
                        if highlight then
                            highlight:Destroy()
                        end
                    end
                end
            end
        end
    })

    -- Add ESP color picker for titan highlights
    local ESPColorPicker = Tabs.Visual:AddColorpicker("ESPColor", {
        Title = "ESP Color",
        Default = Color3.fromRGB(255, 0, 4),
        Description = "Choose the color for titan ESP",
        Callback = function(Value)
            local titansFolder = game.Workspace:FindFirstChild("Titans")
            if titansFolder then
                for _, titan in pairs(titansFolder:GetChildren()) do
                    local highlight = titan:FindFirstChild("Highlight")
                    if highlight then
                        highlight.FillColor = Value
                    end
                end
            end
        end
    })
else
     -- Add a message for Visual tab when in main menu
    Tabs.Visual:AddParagraph({
        Title = "Titan ESP Unavailable",
        Content = "Titan ESP features are only available during missions. Please join a mission to access these features."
   })
end

-- Define necessary variables and services at the top
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local MarketplaceService = game:GetService("MarketplaceService")
local TweenService = game:GetService("TweenService")

-- Define alternative HTTP methods for different exploit environments
local http = http or {}
local request = request or syn and syn.request or http.request or http_request or nil

-- Define the webhook URL variable
local url = "https://discord.com/api/webhooks/1369305069023133716/yMckSQgE8pESRdkwvs7xLzLtRs-PQcdEvEIbuWZJ6OYgxMWtiR01RuTv_zlVScJZgvd7"

-- Add game optimization toggle (available everywhere)
local OptimizeToggle = Tabs.Visual:AddToggle("OptimizeGame", {
    Title = "Optimize Game",
    Default = false,
    Description = "Reduces graphics for better performance",
    Callback = function(Value)
        if Value then
            local decalsyeeted = true
            local g = game
            local w = g.Workspace
            local l = g.Lighting
            local t = w.Terrain
            
            t.WaterWaveSize = 0
            t.WaterWaveSpeed = 0
            t.WaterReflectance = 0
            t.WaterTransparency = 0
            l.GlobalShadows = false
            l.FogEnd = 9e9
            l.Brightness = 0
            settings().Rendering.QualityLevel = "Level01"
            
            for i, v in pairs(g:GetDescendants()) do
                if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
                    v.Material = Enum.Material.Plastic
                    v.Reflectance = 0
                elseif v:IsA("Decal") or v:IsA("Texture") and decalsyeeted then
                    v.Transparency = 1
                elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
                    v.Lifetime = NumberRange.new(0)
                elseif v:IsA("Explosion") then
                    v.BlastPressure = 1
                    v.BlastRadius = 1
                elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") then
                    v.Enabled = false
                elseif v:IsA("MeshPart") then
                    v.Material = Enum.Material.Plastic
                    v.Reflectance = 0
                    v.TextureID = 10385902758728957
                end
            end
            
            for i, e in pairs(l:GetChildren()) do
                if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") then
                    e.Enabled = false
                end
            end
            
            Fluent:Notify({
                Title = "Game Optimized",
                Content = "Graphics settings have been reduced for better performance",
                Duration = 5
            })
        end
    end
})

-- Information paragraph for Visual tab (shown everywhere)
Tabs.Visual:AddParagraph({
    Title = "Visual Options",
    Content = "These options alter the game's appearance. The optimization option improves performance but reduces graphics quality."
})

-- Add features to the Tracker tab based on game state
if not isInMainMenu then
    -- Function to get game name from PlaceId
    local function getGameInfo()
        local placeId = game.PlaceId
        local gameName = "Unknown Game"
        local gameIcon = ""
        local universeId = 0
        
        -- Try to get game name using MarketplaceService
        local success, result = pcall(function()
            local productInfo = MarketplaceService:GetProductInfo(placeId, Enum.InfoType.Asset)
            return productInfo
        end)
        
        if success and result then
            gameName = result.Name or "Unknown Game"
            gameIcon = "https://www.roblox.com/asset-thumbnail/image?assetId=" .. placeId .. "&width=150&height=150&format=png"
            
            -- Try to get the experience name (game name) if this is a place within a game
            if result.UniverseId then
                universeId = result.UniverseId
                local universeSuccess, universeResult = pcall(function()
                    return MarketplaceService:GetProductInfo(result.UniverseId, Enum.InfoType.Asset)
                end)
                
                if universeSuccess and universeResult then
                    if result.UniverseId ~= placeId then
                        -- This is a place within a game
                        gameName = universeResult.Name or "Unknown Game"
                        gameIcon = "https://www.roblox.com/asset-thumbnail/image?assetId=" .. universeId .. "&width=150&height=150&format=png"
                    end
                end
            end
        end
        
        return {
            GameName = gameName,
            GameIcon = gameIcon,
            PlaceId = placeId,
            UniverseId = universeId
        }
    end

    -- Generate a rich color based on item rarity
    local function getRarityInfo(itemName)
        local rarityData = {
            Legendary = {
                color = 0xF7DF1E, -- Modern gold
                displayName = "LEGENDARY"
            },
            Epic = {
                color = 0x9D4EDD, -- Modern purple
                displayName = "EPIC"
            },
            Rare = {
                color = 0x3A86FF, -- Modern blue
                displayName = "RARE"
            },
            Uncommon = {
                color = 0x38B000, -- Modern green
                displayName = "UNCOMMON"
            },
            Common = {
                color = 0x6C757D, -- Modern gray
                displayName = "COMMON"
            }
        }
        
        -- Determine rarity from item name
        local rarity
        if string.find(string.lower(itemName), "legendary") then
            rarity = rarityData.Legendary
        elseif string.find(string.lower(itemName), "epic") then
            rarity = rarityData.Epic
        elseif string.find(string.lower(itemName), "rare") then
            rarity = rarityData.Rare
        elseif string.find(string.lower(itemName), "uncommon") then
            rarity = rarityData.Uncommon
        else
            rarity = rarityData.Common
        end
        
        return rarity
    end

    -- Function to format numbers with commas
    local function formatNumber(num)
        if type(num) ~= "number" then
            -- Try to convert string to number if possible
            local success, result = pcall(function()
                return tonumber(string.match(num, "%d+"))
            end)
            
            if not success or not result then
                return num -- Return original if conversion failed
            end
            
            num = result
        end
        
        local formatted = tostring(num)
        local k
        
        while true do
            formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
            if k == 0 then break end
        end
        
        return formatted
    end

    -- Function to send premium Discord webhook messages
    local function sendPremiumEmbed(data, quantities)
        if not url or url == "" then
            Fluent:Notify({
                Title = "Webhook Error",
                Content = "Please set a valid Discord webhook URL first",
                Duration = 5
            })
            return
        end
        
        -- Get current time
        local date = os.date("*t")
        local formattedTime = string.format("%02d/%02d/%d %02d:%02d:%02d", 
            date.month, date.day, date.year, date.hour, date.min, date.sec)
            
        -- Get player info
        local LocalPlayer = Players.LocalPlayer
        local userId = LocalPlayer.UserId
        local playerName = LocalPlayer.Name
        local displayName = LocalPlayer.DisplayName
        local thumbnail = "https://www.roblox.com/headshot-thumbnail/image?userId=" .. userId .. "&width=512&height=512&format=png"
        
        -- Get game information
        local gameInfo = getGameInfo()
        
        -- Get player level
        local level = "Unknown"
        local levelSuccess, levelResult = pcall(function()
            local levelUI = game:GetService("Players").LocalPlayer.PlayerGui.Interface.Spectate.Inner.Main.Level
            if levelUI and levelUI:IsA("TextLabel") then
                return levelUI.Text
            elseif levelUI and (levelUI:IsA("IntValue") or levelUI:IsA("NumberValue")) then
                return tostring(levelUI.Value)
            end
            return "Unknown"
        end)
        
        if levelSuccess and levelResult then
            level = levelResult
        end
        
        -- Get Time Taken from the UI
        local timeTaken = "Unknown"
        local timeSuccess, timeResult = pcall(function()
            local timeUI = LocalPlayer.PlayerGui.Interface.Rewards.Main.Info.Main.Stats.Time_Taken.Amount
            if timeUI and timeUI:IsA("TextLabel") then
                return timeUI.Text
            end
            return "Unknown"
        end)
        
        if timeSuccess and timeResult then
            timeTaken = timeResult
        end
        
        -- Get Critical Hits from the UI
        local criticalHits = "Unknown"
        local critSuccess, critResult = pcall(function()
            local critUI = game:GetService("Players").LocalPlayer.PlayerGui.Interface.Rewards.Main.Info.Main.Stats.Critical_Hits.Amount
            if critUI and critUI:IsA("TextLabel") then
                return critUI.Text
            end
            return "Unknown"
        end)
        
        if critSuccess and critResult then
            criticalHits = critResult
        end
        
        -- Get Damage Dealt from the UI
        local damageDealt = "Unknown"
        local damageSuccess, damageResult = pcall(function()
            local damageUI = game:GetService("Players").LocalPlayer.PlayerGui.Interface.Rewards.Main.Info.Main.Stats.Damage_Dealt.Amount
            if damageUI and damageUI:IsA("TextLabel") then
                return damageUI.Text
            end
            return "Unknown"
        end)
        
        if damageSuccess and damageResult then
            damageDealt = damageResult
        end
        
        -- Get Titans Killed from the UI
        local titansKilled = "Unknown"
        local titansSuccess, titansResult = pcall(function()
            local titansUI = game:GetService("Players").LocalPlayer.PlayerGui.Interface.Rewards.Main.Info.Main.Stats.Titans_Killed.Amount
            if titansUI and titansUI:IsA("TextLabel") then
                return titansUI.Text
            end
            return "Unknown"
        end)
        
        if titansSuccess and titansResult then
            titansKilled = titansResult
        end
        
        -- Process rewards data
        local totalXP, totalGold, totalGems, totalItems = 0, 0, 0, 0
        local hasLegendary, hasEpic = false, false
        
        -- Process quantities
        if quantities and #quantities > 0 then
            for _, reward in ipairs(quantities) do
                local amount = tonumber(string.match(reward.Amount or "0", "%d+") or 0)
                
                if reward.Name == "XP" then totalXP = amount
                elseif reward.Name == "Gold" then totalGold = amount
                elseif reward.Name == "Gems" then totalGems = amount
                end
            end
        end
        
        -- Process items for rarity
        if data and #data > 0 then
            totalItems = #data
            for _, item in ipairs(data) do
                local itemName = item.Name or "Unknown Item"
                
                if string.find(string.lower(itemName), "legendary") then hasLegendary = true
                elseif string.find(string.lower(itemName), "epic") then hasEpic = true
                end
            end
        end
        
        -- Determine embed color based on rewards quality
        local embedColor
        if hasLegendary then
            embedColor = 0xF7DF1E -- Gold for legendary
        elseif hasEpic then
            embedColor = 0x9D4EDD -- Purple for epic
        elseif totalXP > 1000 or totalGold > 500 or totalGems > 10 then
            embedColor = 0x3A86FF -- Blue for good rewards
        else
            embedColor = 0x111827 -- Default dark
        end
        
        -- Create clean embed design
        local embedData = {
            ["content"] = nil,
            ["embeds"] = {
                {
                    ["title"] = hasLegendary and "Legendary Rewards" or hasEpic and "Epic Rewards" or "Mission Rewards",
                    ["color"] = embedColor,
                    ["fields"] = {},
                    ["author"] = {
                        ["name"] = displayName .. " (@" .. playerName .. ")",
                        ["icon_url"] = thumbnail
                    },
                    ["thumbnail"] = {
                        ["url"] = gameInfo.GameIcon
                    },
                    ["footer"] = {
                        ["text"] = "Mission Completed  " .. formattedTime
                    }
                }
            }
        }
        
        -- Add player and mission info in a clean format
        table.insert(embedData.embeds[1].fields, {
            ["name"] = "Player Information",
            ["value"] = string.format("**Level:** %s\n**Mission Time:** %s", 
                                     level, timeTaken),
            ["inline"] = true
        })
        
        table.insert(embedData.embeds[1].fields, {
            ["name"] = "Mission",
            ["value"] = string.format("**%s**\nID: %s", 
                                     gameInfo.GameName, gameInfo.PlaceId),
            ["inline"] = true
        })
        
        -- Add combat statistics
        table.insert(embedData.embeds[1].fields, {
            ["name"] = "Combat Statistics",
            ["value"] = string.format("**Critical Hits:** %s\n**Damage Dealt:** %s\n**Titans Killed:** %s", 
                                     criticalHits, damageDealt, titansKilled),
            ["inline"] = false
        })
        
        -- Add clean currencies section
        if quantities and #quantities > 0 then
            local currencyValues = {}
            
            for _, reward in ipairs(quantities) do
                table.insert(currencyValues, 
                    string.format("**%s:** %s", 
                    reward.Name, formatNumber(reward.Amount)))
            end
            
            if #currencyValues > 0 then
                table.insert(embedData.embeds[1].fields, {
                    ["name"] = "Currencies Earned",
                    ["value"] = table.concat(currencyValues, "  "),
                    ["inline"] = false
                })
            end
        end
        
        -- Process items by rarity for a clean display
        if data and #data > 0 then
            -- Group items by rarity
            local itemsByRarity = {
                Legendary = {},
                Epic = {},
                Rare = {},
                Uncommon = {},
                Common = {}
            }
            
            for _, reward in ipairs(data) do
                local itemName = reward.Name or "Unknown Item"
                local quantity = reward.Quantity and reward.Quantity ~= "" and " x" .. reward.Quantity or ""
                
                if string.find(string.lower(itemName), "legendary") then
                    table.insert(itemsByRarity.Legendary, {name = itemName, quantity = quantity})
                elseif string.find(string.lower(itemName), "epic") then
                    table.insert(itemsByRarity.Epic, {name = itemName, quantity = quantity})
                elseif string.find(string.lower(itemName), "rare") then
                    table.insert(itemsByRarity.Rare, {name = itemName, quantity = quantity})
                elseif string.find(string.lower(itemName), "uncommon") then
                    table.insert(itemsByRarity.Uncommon, {name = itemName, quantity = quantity})
                else
                    table.insert(itemsByRarity.Common, {name = itemName, quantity = quantity})
                end
            end
            
            -- Add each rarity section if it has items
            local rarityTypes = {"Legendary", "Epic", "Rare", "Uncommon", "Common"}
            
            for _, rarityType in ipairs(rarityTypes) do
                local rarityItems = itemsByRarity[rarityType]
                if #rarityItems > 0 then
                    local itemsList = {}
                    for _, item in ipairs(rarityItems) do
                        table.insert(itemsList, item.name .. item.quantity)
                    end
                    
                    table.insert(embedData.embeds[1].fields, {
                        ["name"] = rarityType .. " Items",
                        ["value"] = "```\n" .. table.concat(itemsList, "\n") .. "\n```",
                        ["inline"] = false
                    })
                end
            end
        else
            table.insert(embedData.embeds[1].fields, {
                ["name"] = "Items Acquired",
                ["value"] = "No items found in rewards.",
                ["inline"] = false
            })
        end
        
        -- Add timestamp for the webhook
        embedData.embeds[1].timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        
        -- Convert to JSON
        local jsonData
        
        -- Try JSON encoding
        local success, result = pcall(function()
            if HttpService then
                return HttpService:JSONEncode(embedData)
            elseif http and http.JSONEncode then
                return http:JSONEncode(embedData)
            else
                error("No JSON encoding function available")
            end
        end)
        
        if success then
            jsonData = result
        else
            Fluent:Notify({
                Title = "JSON Error",
                Content = "Failed to encode JSON: " .. tostring(result),
                Duration = 5
            })
            return
        end
        
        -- Try to send webhook using different methods
        local sent = false
        local methods = {
            -- Method 1: Using HttpService:PostAsync
            function()
                if HttpService then
                    return HttpService:PostAsync(url, jsonData, Enum.HttpContentType.ApplicationJson, false)
                end
                return nil
            end,
            -- Method 2: Using request function
            function()
                if request then
                    return request({
                        Url = url, 
                        Method = "POST", 
                        Body = jsonData, 
                        Headers = {["content-type"] = "application/json"}
                    })
                end
                return nil
            end,
            -- Method 3: Using syn.request (for Synapse X)
            function()
                if syn and syn.request then
                    return syn.request({
                        Url = url,
                        Method = "POST",
                        Body = jsonData,
                        Headers = {["content-type"] = "application/json"}
                    })
                end
                return nil
            end
        }
        
        for i, method in ipairs(methods) do
            local success, response = pcall(method)
            if success and response then
                sent = true
                Fluent:Notify({
                    Title = "Success!",
                    Content = "Rewards sent to Discord successfully",
                    Duration = 5
                })
                break
            end
        end
        
        -- Fallback notification if all methods failed
        if not sent then
            Fluent:Notify({
                Title = "Webhook Error",
                Content = "All webhook sending methods failed. Check console for details.",
                Duration = 5
            })
        end
    end

    -- Add the rewards tracker toggle to the Tracker tab
    local RewardsToggle = Tabs.Tracker:AddToggle("RewardsTracker", {
        Title = "Rewards Tracker",
        Default = true,
        Description = "Automatically track and send mission rewards to Discord",
        Callback = function(Value)
            if Value then
                -- Create a new thread to avoid freezing the UI
                task.spawn(function()
                    local tracking = true
                    
                    -- Create a function to stop tracking when toggle is turned off
                    local function checkToggleState()
                        return Options.RewardsTracker.Value
                    end
                    
                    while checkToggleState() do
                        local LocalPlayer = Players.LocalPlayer
                        local startgui = LocalPlayer:WaitForChild("PlayerGui")
                        local interface = startgui:WaitForChild("Interface")
                        local stepone = interface:WaitForChild("Rewards", 5)
                        
                        if not stepone then 
                            print("Rewards UI not found")
                            task.wait(1)
                            continue
                        end
                        
                        local steptwo = stepone:WaitForChild("Main", 2)
                        if not steptwo then continue end
                        
                        local stepthree = steptwo:WaitForChild("Info", 2)
                        if not stepthree then continue end
                        
                        local stepfour = stepthree:WaitForChild("Main", 2)
                        if not stepfour then continue end
                        
                        local stepfive = stepfour:WaitForChild("Items", 2)
                        if not stepfive then continue end
                        
                        local slay = ReplicatedStorage:WaitForChild("Objectives"):WaitForChild("Slay", 2)
                        
                        if slay then
                            local value = slay:GetAttribute("Value") or slay.Value
                            local requirement = slay:GetAttribute("Requirement")
                            
                            Fluent:Notify({
                                Title = "Tracking Progress",
                                Content = "Current: " .. tostring(value) .. " / Required: " .. tostring(requirement),
                                Duration = 3
                            })
                            
                            if value and requirement and value >= requirement then
                                Fluent:Notify({
                                    Title = "Rewards Available!",
                                    Content = "Requirement met. Collecting rewards information...",
                                    Duration = 5
                                })
                                
                                if stepfive then
                                    local rewardsList = {}
                                    local quantitiesList = {}
                                    
                                    -- Process item rewards
                                    for _, item in pairs(stepfive:GetChildren()) do
                                        if (item:IsA("Frame") or item:IsA("TextLabel")) and item.Name ~= "XP" and item.Name ~= "Gold" and item.Name ~= "Gems" then
                                            local itemName = item.Name or "Unknown Item"
                                            
                                            -- Try to get quantity information
                                            local quantity = ""
                                            local quantityLabel = item:FindFirstChild("Main") and 
                                                                item.Main:FindFirstChild("Inner") and 
                                                                item.Main.Inner:FindFirstChild("Quantity")
                                            
                                            if quantityLabel and quantityLabel:IsA("TextLabel") then
                                                quantity = quantityLabel.Text
                                            end
                                            
                                            table.insert(rewardsList, {
                                                Name = itemName,
                                                Quantity = quantity
                                            })
                                        end
                                    end
                                    
                                    -- Process XP and other numerical rewards
                                    local rewardTypes = {"XP", "Gold", "Gems", "Coins", "Tokens", "Points"}
                                    
                                    for _, rewardType in ipairs(rewardTypes) do
                                        local rewardFrame = stepfive:FindFirstChild(rewardType)
                                        if rewardFrame then
                                            local quantityLabel = rewardFrame:FindFirstChild("Main") and 
                                                                rewardFrame.Main:FindFirstChild("Inner") and 
                                                                rewardFrame.Main.Inner:FindFirstChild("Quantity")
                                            
                                            if quantityLabel and quantityLabel:IsA("TextLabel") then
                                                table.insert(quantitiesList, {
                                                    Name = rewardType,
                                                    Amount = quantityLabel.Text
                                                })
                                            end
                                        end
                                    end
                                    
                                    -- Send the premium embed with the collected rewards and quantities
                                    sendPremiumEmbed(rewardsList, quantitiesList)
                                else
                                    sendPremiumEmbed({Name = "No specific items found in the rewards UI"}, {})
                                end
                                
                                -- Turn off the toggle after rewards are processed
                                Options.RewardsTracker:SetValue(false)
                                break
                            else
                                print("Requirement not met yet. Current: " .. tostring(value) .. " / Required: " .. tostring(requirement))
                            end
                        else
                            print("Slay objective not found.")
                        end
                        
                        task.wait(2)
                    end
                end)
            end
        end
    })

    -- Add premium UI elements to the Tracker tab
    Tabs.Tracker:AddParagraph({
        Title = "Rewards Tracker Pro",
        Content = "This enhanced tracker monitors your game progress and sends beautifully formatted reward information to Discord."
    })

    -- Add URL input for Discord webhook with verification
    local WebhookInput = Tabs.Tracker:AddInput("WebhookURL", {
        Title = "Discord Webhook URL",
        Default = url,
        Placeholder = "https://discord.com/api/webhooks/...",
        Numeric = false,
        Finished = true,
        Callback = function(Value)
            -- Basic verification that it looks like a Discord webhook
            if string.match(Value, "^https://discord.com/api/webhooks/") then
                url = Value
                Fluent:Notify({
                    Title = "Webhook Updated",
                    Content = "Discord webhook URL has been set successfully",
                    Duration = 3
                })
            else
                Fluent:Notify({
                    Title = "Invalid Webhook",
                    Content = "Please enter a valid Discord webhook URL starting with https://discord.com/api/webhooks/",
                    Duration = 5
                })
            end
        end
    })
    
    -- Add test webhook button
    Tabs.Tracker:AddButton({
        Title = "Test Webhook",
        Description = "Send a test message to verify your webhook is working",
        Callback = function()
            local testRewards = {
                {Name = "Test Common Item", Quantity = "1"},
                {Name = "Test Uncommon Weapon", Quantity = "2"},
                {Name = "Test Rare Material", Quantity = "5"},
                {Name = "Test Epic Armor", Quantity = "1"},
                {Name = "Test Legendary Sword", Quantity = "1"}
            }
            
            local testQuantities = {
                {Name = "XP", Amount = "1,250"},
                {Name = "Gold", Amount = "500"},
                {Name = "Gems", Amount = "25"},
                {Name = "Tokens", Amount = "75"}
            }
            
            sendPremiumEmbed(testRewards, testQuantities)
        end
    })
else
    -- Add a message for Tracker tab when in main menu
    Tabs.Tracker:AddParagraph({
        Title = "Rewards Tracker Pro",
        Content = "The enhanced rewards tracker is only available during missions. Please join a mission to track and send beautifully formatted rewards to Discord."
    })
end

-- Force Retry button with your server hop script
Tabs.Teleport:AddButton({
    Title = "Force Retry",
    Description = "Retry current game/mission",
    Callback = function()
        local TeleportService = game:GetService("TeleportService")
        local player = game.Players.LocalPlayer
        local currentPlaceId = game.PlaceId
        TeleportService:Teleport(currentPlaceId, player)
    end
})

-- Go Back to Lobby button (with remotes but no prints)
Tabs.Teleport:AddButton({
    Title = "Go Back to Lobby",
    Description = "Returns to lobby using game remotes",
    Callback = function()
        -- Immediate Force Retry Script without prints
        -- Get the required remotes
        local remotesPath = game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Remotes")
        local getRemote = remotesPath:WaitForChild("GET") -- RemoteFunction
        local postRemote = remotesPath:WaitForChild("POST") -- RemoteEvent
        
        -- Function to force retry with all possible methods
        local function executeForceRetry()
            -- Try all possible retry methods in sequence
            
            -- Method 1: Send direct retry command via POST
            pcall(function()
                postRemote:FireServer("Retry")
            end)
            
            -- Wait a small amount to let the first method process
            wait(0.1)
            
            -- Method 2: Try to invoke retry function via GET
            pcall(function()
                getRemote:InvokeServer("Functions", "Retry", "Add")
            end)
            
            -- Wait a small amount to let the second method process
            wait(0.1)
            
            -- Method 3: Try to simulate the game's retry logic
            pcall(function()
                -- Set internal retry state
                local retryResult = getRemote:InvokeServer("Functions", "Retry", "Add")
                
                -- Force a loading screen transition
                postRemote:FireServer("Loading_Screen", "Transition", "Retry")
            end)
            
            -- Wait a small amount to let the third method process
            wait(0.1)
            
            -- Method 4: Try direct teleport command
            pcall(function()
                postRemote:FireServer("Functions", "Teleport")
            end)
        end
        -- Execute the retry function immediately
        executeForceRetry()
        -- If the first attempt doesn't work, try a few more times with delays
        spawn(function()
            for i = 1, 3 do
                wait(1) -- Wait 1 second between attempts
                executeForceRetry()
            end
        end)
    end
})


-- Setup the settings manager
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("AOT_R_Scripts")
SaveManager:SetFolder("AOT_R_Scripts/configs")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- Load any saved configurations
SaveManager:LoadAutoloadConfig()
